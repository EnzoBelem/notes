### ğŸ“Œ `dataclasses` no Python

O mÃ³dulo `dataclasses` foi introduzido no Python 3.7 para simplificar a criaÃ§Ã£o de classes que representam **estruturas de dados**. Ele reduz o **boilerplate** (cÃ³digo repetitivo) necessÃ¡rio para definir classes, fornecendo automaticamente mÃ©todos como `__init__`, `__repr__`, `__eq__`, e outros.

https://www.youtube.com/watch?v=NtZY3AmsBSk

---

## ğŸš€ Vantagens das `dataclasses`

âœ” CÃ³digo mais **limpo e organizado**    
âœ” Suporte a **tipagem estÃ¡tica**  
âœ” MÃ©todos automÃ¡ticos (`__init__`, `__repr__`, `__eq__`, etc.)  
âœ” Permite **mutabilidade opcional**  
âœ” Melhor **integraÃ§Ã£o com IDEs e ferramentas de anÃ¡lise de tipo**

---

## ğŸ¯ Como usar `dataclass`

A estrutura bÃ¡sica Ã©:

```python
from dataclasses import dataclass

@dataclass
class Pessoa:
    nome: str
    idade: int
    cidade: str

p1 = Pessoa(nome="Carlos", idade=30, cidade="Teresina")

print(p1)  # Pessoa(nome='Carlos', idade=30, cidade='Teresina')
```

ğŸ’¡ **Sem precisar definir `__init__`, `__repr__` e `__eq__`!**

---

## ğŸ›  Recursos Ãºteis de `dataclass`

### ğŸ”¹ **Campos opcionais e valores padrÃ£o**

Podemos definir valores padrÃ£o para os atributos:

```python
@dataclass
class Pessoa:
    nome: str
    idade: int = 18  # Valor padrÃ£o
    cidade: str = "Desconhecida"

p1 = Pessoa("Ana")
print(p1)  # Pessoa(nome='Ana', idade=18, cidade='Desconhecida')
```

---

### ğŸ”¹ **Mutabilidade e Imutabilidade**

Por padrÃ£o, `dataclass` cria objetos **mutÃ¡veis**, mas podemos tornÃ¡-los imutÃ¡veis:

```python
@dataclass(frozen=True)
class Pessoa:
    nome: str
    idade: int

p1 = Pessoa("Ana", 25)
# p1.idade = 30  # âŒ Isso geraria um erro, pois a classe Ã© imutÃ¡vel
```

---

### ğŸ”¹ **Ignorar campos no `__init__`**

Se um campo nÃ£o deve ser incluÃ­do no `__init__`, usamos `field(init=False)`:

```python
from dataclasses import dataclass, field

@dataclass
class Contador:
    nome: str
    _contador: int = field(default=0, init=False)

    def incrementar(self):
        self._contador += 1

c = Contador("Clicks")
c.incrementar()
print(c)  # Contador(nome='Clicks', _contador=1)
```

---

## ğŸ“Œ ComparaÃ§Ã£o: `dataclass` vs. `namedtuple` vs. `NamedTuple`

|CaracterÃ­stica|`dataclass`|`collections.namedtuple`|`typing.NamedTuple`|
|---|---|---|---|
|MutÃ¡vel?|âœ… Sim (padrÃ£o) / âŒ Pode ser imutÃ¡vel|âŒ NÃ£o|âŒ NÃ£o|
|MÃ©todos personalizados|âœ… Sim|âœ… Sim (mas incomum)|âœ… Sim|
|Tipagem|âœ… Sim|âŒ NÃ£o|âœ… Sim|
|Melhor para anÃ¡lise estÃ¡tica|âœ… Sim|âŒ NÃ£o|âœ… Sim|
|Melhor para estruturas de dados complexas|âœ… Sim|âŒ NÃ£o|âŒ NÃ£o|

---

## ğŸ¯ Quando usar `dataclass`?

âœ… Se precisar de **uma classe mutÃ¡vel com menos cÃ³digo repetitivo**  
âœ… Se precisar de **tipagem estÃ¡tica** e **suporte a ferramentas modernas**  
âœ… Se precisar **armazenar dados com flexibilidade e possÃ­veis modificaÃ§Ãµes**

Se precisar de algo **imutÃ¡vel e leve**, prefira `NamedTuple`. Se quiser algo **mais estruturado e flexÃ­vel**, use `dataclass`. ğŸš€